#!/usr/bin/env python3
"""
Proactive Orchestration Engine (POE) for Roo Commander
Implements intelligent project analysis and suggestion generation
"""

import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum

class SuggestionType(Enum):
    RISK_WARNING = "risk_warning"
    OPPORTUNITY = "opportunity"
    NEXT_STEP = "next_step"
    OPTIMIZATION = "optimization"
    MAINTENANCE = "maintenance"

class Priority(Enum):
    CRITICAL = "critical"
    HIGH = "high" 
    MEDIUM = "medium"
    LOW = "low"

@dataclass
class ProjectStateSnapshot:
    """Current project state derived from ConPort data"""
    active_tasks: List[Dict]
    recent_decisions: List[Dict]
    progress_items: List[Dict]
    system_patterns: List[Dict]
    custom_data: Dict[str, Any]
    linked_items: Dict[str, List[Dict]]
    timestamp: datetime

@dataclass
class Suggestion:
    """Actionable suggestion generated by POE"""
    id: str
    type: SuggestionType
    priority: Priority
    title: str
    description: str
    rationale: str
    suggested_actions: List[str]
    context_items: List[str]
    confidence_score: float
    created_at: datetime

class ProjectStateAnalyzer:
    """Analyzes ConPort data to build comprehensive project state"""
    
    def __init__(self, conport_client):
        self.conport = conport_client
        self.logger = logging.getLogger(__name__)
    
    async def analyze_project_state(self, workspace_id: str) -> ProjectStateSnapshot:
        """Build comprehensive project state from ConPort data"""
        try:
            # Gather core data from ConPort
            active_tasks = await self._get_active_tasks()
            recent_decisions = await self._get_recent_decisions()
            progress_items = await self._get_progress_items()
            system_patterns = await self._get_system_patterns()
            custom_data = await self._get_relevant_custom_data()
            linked_items = await self._analyze_linked_relationships()
            
            return ProjectStateSnapshot(
                active_tasks=active_tasks,
                recent_decisions=recent_decisions,
                progress_items=progress_items,
                system_patterns=system_patterns,
                custom_data=custom_data,
                linked_items=linked_items,
                timestamp=datetime.now()
            )
        except Exception as e:
            self.logger.error(f"Project state analysis failed: {e}")
            return self._empty_snapshot()
    
    async def _get_active_tasks(self) -> List[Dict]:
        """Get currently active MDTM tasks"""
        # Implementation would query ConPort for active progress items
        return []
    
    async def _get_recent_decisions(self) -> List[Dict]:
        """Get recent architectural decisions"""
        # Implementation would query ConPort decisions
        return []
    
    async def _get_progress_items(self) -> List[Dict]:
        """Get progress tracking items"""
        # Implementation would query ConPort progress
        return []
    
    async def _get_system_patterns(self) -> List[Dict]:
        """Get defined system patterns"""
        # Implementation would query ConPort system patterns
        return []
    
    async def _get_relevant_custom_data(self) -> Dict[str, Any]:
        """Get relevant custom data categories"""
        # Implementation would query ConPort custom data
        return {}
    
    async def _analyze_linked_relationships(self) -> Dict[str, List[Dict]]:
        """Analyze item relationships and link density"""
        # Implementation would analyze ConPort links
        return {}
    
    def _empty_snapshot(self) -> ProjectStateSnapshot:
        """Return empty snapshot for error cases"""
        return ProjectStateSnapshot(
            active_tasks=[],
            recent_decisions=[],
            progress_items=[],
            system_patterns=[],
            custom_data={},
            linked_items={},
            timestamp=datetime.now()
        )

class OpportunityRiskIdentifier:
    """Identifies risks and opportunities from project state"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.risk_rules = self._load_risk_rules()
        self.opportunity_rules = self._load_opportunity_rules()
    
    def identify_issues_and_opportunities(self, state: ProjectStateSnapshot) -> List[Tuple[str, Dict]]:
        """Apply rules to identify risks and opportunities"""
        findings = []
        
        # Apply risk detection rules
        for rule in self.risk_rules:
            risks = self._apply_risk_rule(rule, state)
            findings.extend([("risk", risk) for risk in risks])
        
        # Apply opportunity detection rules  
        for rule in self.opportunity_rules:
            opportunities = self._apply_opportunity_rule(rule, state)
            findings.extend([("opportunity", opp) for opp in opportunities])
        
        return findings
    
    def _load_risk_rules(self) -> List[Dict]:
        """Load risk detection rules"""
        return [
            {
                "id": "overdue_tasks",
                "name": "Overdue Task Detection",
                "condition": "task_overdue",
                "severity": "high",
                "message_template": "Task '{task_name}' is overdue by {days} days"
            },
            {
                "id": "blocked_tasks", 
                "name": "Blocked Task Detection",
                "condition": "task_blocked",
                "severity": "medium",
                "message_template": "Task '{task_name}' has been blocked for {duration}"
            },
            {
                "id": "unlinked_decisions",
                "name": "Unlinked Decision Detection", 
                "condition": "decision_unlinked",
                "severity": "low",
                "message_template": "Decision '{decision}' has no implementation links"
            }
        ]
    
    def _load_opportunity_rules(self) -> List[Dict]:
        """Load opportunity detection rules"""
        return [
            {
                "id": "ready_next_steps",
                "name": "Ready Next Steps",
                "condition": "next_step_available",
                "priority": "medium",
                "message_template": "Ready to proceed with '{next_step}'"
            },
            {
                "id": "pattern_application",
                "name": "Pattern Application Opportunity",
                "condition": "pattern_applicable", 
                "priority": "low",
                "message_template": "System pattern '{pattern}' could be applied to '{context}'"
            }
        ]
    
    def _apply_risk_rule(self, rule: Dict, state: ProjectStateSnapshot) -> List[Dict]:
        """Apply a specific risk rule to project state"""
        # Implementation would evaluate rule conditions against state
        return []
    
    def _apply_opportunity_rule(self, rule: Dict, state: ProjectStateSnapshot) -> List[Dict]:
        """Apply a specific opportunity rule to project state"""
        # Implementation would evaluate rule conditions against state
        return []

class SuggestionFormulator:
    """Converts raw findings into actionable suggestions"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def formulate_suggestions(self, findings: List[Tuple[str, Dict]]) -> List[Suggestion]:
        """Convert findings into prioritized suggestions"""
        suggestions = []
        
        for finding_type, finding_data in findings:
            suggestion = self._create_suggestion(finding_type, finding_data)
            if suggestion:
                suggestions.append(suggestion)
        
        # Sort by priority and confidence
        suggestions.sort(key=lambda s: (s.priority.value, -s.confidence_score))
        
        return suggestions
    
    def _create_suggestion(self, finding_type: str, finding_data: Dict) -> Optional[Suggestion]:
        """Create a suggestion from a finding"""
        try:
            suggestion_id = f"POE-{datetime.now().strftime('%Y%m%d%H%M%S')}-{finding_data.get('id', 'unknown')}"
            
            if finding_type == "risk":
                return self._create_risk_suggestion(suggestion_id, finding_data)
            elif finding_type == "opportunity":
                return self._create_opportunity_suggestion(suggestion_id, finding_data)
            
            return None
        except Exception as e:
            self.logger.error(f"Failed to create suggestion: {e}")
            return None
    
    def _create_risk_suggestion(self, suggestion_id: str, risk_data: Dict) -> Suggestion:
        """Create risk-based suggestion"""
        return Suggestion(
            id=suggestion_id,
            type=SuggestionType.RISK_WARNING,
            priority=Priority.HIGH,
            title=f"Risk: {risk_data.get('name', 'Unknown Risk')}",
            description=risk_data.get('description', ''),
            rationale=risk_data.get('rationale', ''),
            suggested_actions=risk_data.get('actions', []),
            context_items=risk_data.get('context', []),
            confidence_score=risk_data.get('confidence', 0.8),
            created_at=datetime.now()
        )
    
    def _create_opportunity_suggestion(self, suggestion_id: str, opp_data: Dict) -> Suggestion:
        """Create opportunity-based suggestion"""
        return Suggestion(
            id=suggestion_id,
            type=SuggestionType.OPPORTUNITY,
            priority=Priority.MEDIUM,
            title=f"Opportunity: {opp_data.get('name', 'Unknown Opportunity')}",
            description=opp_data.get('description', ''),
            rationale=opp_data.get('rationale', ''),
            suggested_actions=opp_data.get('actions', []),
            context_items=opp_data.get('context', []),
            confidence_score=opp_data.get('confidence', 0.7),
            created_at=datetime.now()
        )

class ProactiveOrchestrationEngine:
    """Main POE class that orchestrates analysis and suggestion generation"""
    
    def __init__(self, conport_client):
        self.conport = conport_client
        self.analyzer = ProjectStateAnalyzer(conport_client)
        self.identifier = OpportunityRiskIdentifier()
        self.formulator = SuggestionFormulator()
        self.logger = logging.getLogger(__name__)
    
    async def generate_suggestions(self, workspace_id: str) -> List[Suggestion]:
        """Main entry point for suggestion generation"""
        try:
            # Step 1: Analyze current project state
            self.logger.info("Analyzing project state...")
            state = await self.analyzer.analyze_project_state(workspace_id)
            
            # Step 2: Identify risks and opportunities
            self.logger.info("Identifying risks and opportunities...")
            findings = self.identifier.identify_issues_and_opportunities(state)
            
            # Step 3: Formulate actionable suggestions
            self.logger.info("Formulating suggestions...")
            suggestions = self.formulator.formulate_suggestions(findings)
            
            # Step 4: Log suggestion generation to ConPort
            await self._log_suggestion_generation(workspace_id, len(suggestions))
            
            return suggestions
            
        except Exception as e:
            self.logger.error(f"POE suggestion generation failed: {e}")
            return []
    
    async def _log_suggestion_generation(self, workspace_id: str, suggestion_count: int):
        """Log POE activity to ConPort"""
        try:
            # Log POE execution as custom data
            await self.conport.log_custom_data(
                workspace_id=workspace_id,
                category="POE_Activity",
                key=f"suggestion_run_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                value={
                    "timestamp": datetime.now().isoformat(),
                    "suggestions_generated": suggestion_count,
                    "engine_version": "1.0.0"
                }
            )
        except Exception as e:
            self.logger.error(f"Failed to log POE activity: {e}")

# Usage example for Roo Commander integration
async def integrate_with_roo_commander(workspace_id: str, conport_client):
    """Integration point for Roo Commander"""
    poe = ProactiveOrchestrationEngine(conport_client)
    suggestions = await poe.generate_suggestions(workspace_id)
    
    # Filter and present top suggestions
    top_suggestions = suggestions[:3]  # Limit to top 3
    
    for suggestion in top_suggestions:
        # Roo Commander would present these suggestions autonomously
        # Implementation would integrate with existing Roo Commander logic
        print(f"POE Suggestion: {suggestion.title}")
        print(f"Priority: {suggestion.priority.value}")
        print(f"Actions: {', '.join(suggestion.suggested_actions)}")
        print("---")
    
    return top_suggestions
